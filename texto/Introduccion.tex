\chapter*{Introducción}
\addcontentsline{toc}{chapter}{Introducción}

El objetivo del trabajo es la implementación de los algoritmos de la lógica de
primer orden en Haskell. Consta de dos partes:

\begin{itemize}
\item La primera parte consiste en la implementación en Haskell de la teoría
  impartida en la asignatura
  \href{https://www.cs.us.es/~jalonso/cursos/lmf-15} 
       {Lógica matemática y fundamentos}\
  \footnote{\url{{https://www.cs.us.es/~jalonso/cursos/lmf-15}}}
  (\cite{Alonso-15a}). Para ello, se lleva a cabo la adaptación de los programas del libro de
  J. van Eijck 
  \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.467.1441&rep=rep1&type=pdf}
       {Computational semantics and type theory}\
  \footnote{\url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.467.1441&rep=rep1&type=pdf}}
  (\cite{Eijck-03}) y su correspondiente teoría. 

\item En la segunda parte se comentan aquellos sistemas empleados en la elaboración del
  trabajo.
 
\end{itemize}

La lógica de primer orden o lógica de predicados nace como una extensión de la lógica proposicional ante algunas carencias que ésta presenta. La lógica proposicional tiene como objetivo modelizar el razonamiento y nos aporta una manera de formalizar las demostraciones. El problema surge cuando aparecen propiedades universales o nos cuestionamos la existencia de elementos con una cierta propiedad, es decir, aparecen razonamientos del tipo
\begin{center}
  Todos los sevillanos van a la feria. \\
  Yo soy sevillano.\\
  Por lo tanto, voy a la feria
\end{center}
A pesar de ser yo una clara prueba de que la proposición no es cierta, sí que se infieren las carencias de la lógica proposicional.

Una vez que vemos la necesidad de la existencia de la lógica de primer orden, nos damos cuenta de que el progreso nos lleva a la mejora y automatización del razonamiento, y eso desemboca en el empleo de lenguajes informáticos para pasar del ``hombre'' a la ``máquina''. Con este fin, se ha elegido como lenguaje para la implementación Haskell, un lenguaje de programación funcional, y nos vemos motivados a esta elección debido a su cercanía a la representación matemática en su ``enfoque funcional''.

Como se ha comentado antes, se implementarán aquellas cuestiones impartidas en la asignatura de Lógica matemática y fundamentos. Cuestiones como la semántica de la lógica proposicional, resolución, prueba de teoremas, modelos de Herbrand... Todas estas implementaciones desembocan en una pregunta mayor, ¿es la lógica y la programación lo mismo? O más allá, ¿existe una equivalencia entre la programación y las matemáticas? Estas preguntas se ven motivadas ante la posibilidad de implementar distintos ámbitos de las matemáticas, el preguntarnos si cada rama de las matemáticas tiene su clon en formato código, desembocando en el último capítulo de la primera parte, la correspondencia de Curry-Howard que nos da una satisfactoria relación entre ambos campos.

Finalmente, la segunda parte del trabajo consta de una guía sobre github, para el trabajo común entre varias personas a través de esta plataforma y el uso de \texttt{git} en emacs. 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "LPO_en_Haskell"
%%% End: 
